// Copyright Â©2020 Dan Kortschak. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package log implements a work-alike to the standard library's log
// package that writes logging on os.Stdout and os.Stderr to a JSON
// even stream written to os.Stdout. All other output io.Writers are
// treated the same as if written to by the stdlib log package.
package log

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"reflect"
	"runtime"
	"sync"

	"github.com/kortschak/gd/internal/enc"
)

var (
	mu     sync.Mutex
	stdout = &logger{stream: "stdout", w: os.Stdout}
	stderr = &logger{stream: "stderr", w: os.Stderr}
	std    = log.New(stderr, log.Prefix(), log.Flags())
)

// These flags define which text to prefix to each log entry generated by the Logger.
// Bits are or'ed together to control what's printed.
// With the exception of the Lmsgprefix flag, there is no
// control over the order they appear (the order listed here)
// or the format they present (as described in the comments).
// The prefix is followed by a colon only when Llongfile or Lshortfile
// is specified.
// For example, flags Ldate | Ltime (or LstdFlags) produce,
//	2009/01/23 01:23:23 message
// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
const (
	Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
	Ltime                         // the time in the local time zone: 01:23:23
	Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile                     // full file name and line number: /a/b/c/d.go:23
	Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
	LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
	Lmsgprefix                    // move the "prefix" from the beginning of the line to before the message
	LstdFlags     = Ldate | Ltime // initial values for the standard logger
)

type logger struct {
	buf    bytes.Buffer
	stream string
	w      io.Writer
}

func (l *logger) Write(p []byte) (int, error) {
	return l.buf.Write(p)
}

func (l *logger) text() string {
	text := l.buf.String()
	l.buf.Reset()
	return text
}

// Fatal mimics Print() followed by a call to os.Exit(1).
func Fatal(v ...interface{}) {
	output(2, fmt.Sprint(v...))
	fatal("exit status 1")
}

// Fatalf mimics Printf() followed by a call to os.Exit(1).
func Fatalf(format string, v ...interface{}) {
	output(2, fmt.Sprintf(format, v...))
	fatal("exit status 1")
}

// Fatalln mimics Println() followed by a call to os.Exit(1).
func Fatalln(v ...interface{}) {
	output(2, fmt.Sprintln(v...))
	fatal("exit status 1")
}

func fatal(s string) {
	e := enc.Event{
		Stream: "stderr",
		Text:   s,
	}
	_ = enc.Encode(e, 2)
	os.Exit(0)
}

// Flags returns the output flags for the standard logger.
// The flag bits are Ldate, Ltime, and so on.
func Flags() int {
	return std.Flags()
}

// Output writes the output for a logging event. The string s contains
// the text to print after the prefix specified by the flags of the
// Logger. A newline is appended if the last character of s is not
// already a newline. Calldepth is the count of the number of
// frames to skip when computing the file name and line number
// if Llongfile or Lshortfile is set; a value of 1 will print the details
// for the caller of Output.
func Output(calldepth int, s string) error {
	mu.Lock()
	defer mu.Unlock()
	return output(calldepth+1, s)
}

func output(calldepth int, s string) error {
	err := std.Output(calldepth, s)
	if err != nil {
		return err
	}
	w, ok := std.Writer().(*logger)
	if !ok {
		return nil
	}
	e := enc.Event{
		Stream: w.stream,
		Text:   w.text(),
	}
	return enc.Encode(e, 2)
}

// Panic mimics Print() followed by a call to panic().
func Panic(v ...interface{}) {
	output(2, fmt.Sprint(v...))
	buf := make([]byte, 1024)
	for {
//line $GOROOT/src/log/log.go:221
		n := runtime.Stack(buf, false)
		if n < len(buf) {
			buf = buf[:n]
			break
		}
		buf = make([]byte, 2*len(buf))
	}
	buf = bytes.ReplaceAll(buf, pkgPathFunc("Panic"), []byte("log.Panic"))
	e := enc.Event{
		Stream: "stderr",
		Text:   fmt.Sprintf("panic: %s\n\n%s", fmt.Sprint(v...), buf),
	}
	_ = enc.Encode(e, 1)
	os.Exit(0)
}

// Panicf minics Printf() followed by a call to panic().
func Panicf(format string, v ...interface{}) {
	output(2, fmt.Sprintf(format, v...))
	buf := make([]byte, 1024)
	for {
//line $GOROOT/src/log/log.go:228
		n := runtime.Stack(buf, false)
		if n < len(buf) {
			buf = buf[:n]
			break
		}
		buf = make([]byte, 2*len(buf))
	}
	buf = bytes.ReplaceAll(buf, pkgPathFunc("Panic"), []byte("log.Panic"))
	e := enc.Event{
		Stream: "stderr",
		Text:   fmt.Sprintf("panic: %s\n\n%s", fmt.Sprintf(format, v...), buf),
	}
	_ = enc.Encode(e, 1)
	os.Exit(0)
}

// Panicln mimics to Println() followed by a call to panic().
func Panicln(v ...interface{}) {
	output(2, fmt.Sprintln(v...))
	buf := make([]byte, 1024)
	for {
//line $GOROOT/src/log/log.go:235
		n := runtime.Stack(buf, false)
		if n < len(buf) {
			buf = buf[:n]
			break
		}
		buf = make([]byte, 2*len(buf))
	}
	buf = bytes.ReplaceAll(buf, pkgPathFunc("Panic"), []byte("log.Panic"))
	e := enc.Event{
		Stream: "stderr",
		Text:   fmt.Sprintf("panic: %s\n\n%s", fmt.Sprint(v...), buf),
	}
	_ = enc.Encode(e, 1)
	os.Exit(0)
}

func pkgPathFunc(fn string) []byte {
	type me struct{}
	return []byte(reflect.TypeOf(me{}).PkgPath() + "." + fn)
}

// Prefix returns the output prefix for the standard logger.
func Prefix() string {
	return std.Prefix()
}

// Print calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Print.
func Print(v ...interface{}) {
	output(2, fmt.Sprint(v...))
}

// Printf calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Printf.
func Printf(format string, v ...interface{}) {
	output(2, fmt.Sprintf(format, v...))
}

// Println calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Println.
func Println(v ...interface{}) {
	output(2, fmt.Sprintln(v...))
}

// SetFlags sets the output flags for the standard logger.
// The flag bits are Ldate, Ltime, and so on.
func SetFlags(flag int) {
	std.SetFlags(flag)
}

// SetOutput sets the output destination for the standard logger.
func SetOutput(w io.Writer) {
	if _, ok := w.(*os.File); !ok {
		std.SetOutput(w)
		return
	}
	switch w {
	case os.Stdout:
		std.SetOutput(stdout)
	case os.Stderr:
		std.SetOutput(stderr)
	default:
		std.SetOutput(w)
	}
}

// SetPrefix sets the output prefix for the standard logger.
func SetPrefix(prefix string) {
	log.SetPrefix(prefix)
}

// Writer returns the output destination for the standard logger.
func Writer() io.Writer {
	w := std.Writer()
	switch l := w.(type) {
	case *logger:
		return l.w
	default:
		return w
	}
}

// A Logger represents an active logging object that generates lines of
// output to an io.Writer. Each logging operation makes a single call to
// the Writer's Write method. A Logger can be used simultaneously from
// multiple goroutines; it guarantees to serialize access to the Writer.
type Logger = log.Logger

// New creates a new Logger. The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line, or
// after the log header if the Lmsgprefix flag is provided.
// The flag argument defines the logging properties.
func New(out io.Writer, prefix string, flag int) *Logger {
	return log.New(out, prefix, flag)
}
