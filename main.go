// Copyright Â©2020 Dan Kortschak. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// gd renders a single Go source file and it's text and graphic
// output into a single Markdown file.
package main

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/kortschak/gd/internal/enc"
)

func main() {
	inline := flag.Bool("inline", false, "render images as inline data: URIs")
	notice := flag.Bool("notice", true, "prefix file with code generation notice")
	quote := flag.Bool("quote", true, "quote output chunks")
	target := flag.String("o", "", "specify output file (stdout if empty")
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "Usage of %s: %[1]s [options] <src.go>\n\nOptions:\n", os.Args[0])
		flag.PrintDefaults()
	}
	flag.Parse()

	out := io.Writer(os.Stdout)
	if *target != "" {
		f, err := os.Create(*target)
		if err != nil {
			flag.Usage()
			os.Exit(2)
		}
		defer f.Close()
		out = f
	}

	if len(flag.Args()) < 1 {
		flag.Usage()
		os.Exit(2)
	}
	src, err := ioutil.ReadFile(flag.Arg(0))
	if err != nil {
		log.Fatal(err)
	}
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, flag.Arg(0), src, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	// Replace the "fmt" and "show" imports with our hooks.
	for _, decl := range f.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if ok && gen.Tok == token.IMPORT {
			for _, spec := range gen.Specs {
				imp := spec.(*ast.ImportSpec)
				switch imp.Path.Value {
				case `"fmt"`:
					imp.Path.Value = `"github.com/kortschak/gd/fmt"`
				case `"log"`:
					imp.Path.Value = `"github.com/kortschak/gd/log"`
				case `"show"`:
					imp.Path.Value = `"github.com/kortschak/gd/show"`

				}
			}
		}
	}

	// Find C-style comments with leading {md} mark.
	mdText := make(map[int]*ast.Comment)
	for _, c := range f.Comments {
		for _, l := range c.List {
			if strings.HasPrefix(l.Text, "/*{md}\n") {
				mdText[fset.Position(l.Pos()).Line] = l
			}
		}
	}

	events, err := run(fset, f, flag.Args()[1:])
	if err != nil {
		log.Fatal(err)
	}

	longTicks := longestTicks(string(src))
	for _, grp := range events {
		for _, e := range grp {
			n := longestTicks(e.Text)
			if n > longTicks {
				longTicks = n
			}
		}
	}
	ticks := strings.Repeat("`", max(longTicks+1, 3))

	if *notice {
		_, err = fmt.Fprintf(out, "<!-- Code generated by `%v`; DO NOT EDIT. -->\n", formatCLargs(os.Args))
		if err != nil {
			log.Fatal(err)
		}
	}

	rep := strings.NewReplacer("\n", "\n> ")
	sc := bufio.NewScanner(bytes.NewReader(src))
	var line int
	wasComment := true
	for sc.Scan() {
		r, ok := events[line]
		if ok {
			_, err = fmt.Fprintln(out, ticks)
			if err != nil {
				log.Fatal(err)
			}
			for i, e := range r {
				if e.File != flag.Arg(0) {
					log.Fatalf("called event generator in dependency file: %s:%d", e.File, e.Line)
				}
				switch e.Stream {
				case "stdout", "stderr":
					if !strings.HasSuffix(e.Text, "\n") {
						e.Text += "\n"
					}
					if *quote {
						_, err = fmt.Fprintf(out, "> %s%s\n> %s%s\n", ticks, e.Stream, rep.Replace(e.Text), ticks)
						if err != nil {
							log.Fatal(err)
						}
					} else {
						_, err = fmt.Fprintf(out, "%s%s\n%s%s\n", ticks, e.Stream, e.Text, ticks)
						if err != nil {
							log.Fatal(err)
						}
					}
				case "markdown":
					_, err = fmt.Fprint(out, e.Text)
					if err != nil {
						log.Fatal(err)
					}
				case "image":
					if *inline {
						e.Image = strings.TrimPrefix(e.Image, "data:image/svg+xml,")
						if e.Title == "" {
							_, err = fmt.Fprintf(out, "![%s](%s)\n\n", e.Text, e.Image)
							if err != nil {
								log.Fatal(err)
							}
						} else {
							_, err = fmt.Fprintf(out, "![%s](%s %q)\n\n", e.Text, e.Image, e.Title)
							if err != nil {
								log.Fatal(err)
							}
						}
					} else {
						var (
							src    io.Reader
							format string
						)
						switch {
						case strings.HasPrefix(e.Image, "data:image/jpeg;base64,"):
							data := strings.TrimPrefix(e.Image, "data:image/jpeg;base64,")
							src = base64.NewDecoder(base64.StdEncoding, strings.NewReader(data))
							format = "jpeg"
						case strings.HasPrefix(e.Image, "data:image/png;base64,"):
							data := strings.TrimPrefix(e.Image, "data:image/png;base64,")
							src = base64.NewDecoder(base64.StdEncoding, strings.NewReader(data))
							format = "png"
						case strings.HasPrefix(e.Image, "data:image/svg+xml,"):
							data := strings.TrimPrefix(e.Image, "data:image/svg+xml,")
							src = strings.NewReader(data)
							format = "svg"
						default:
							log.Fatalf("unknown image format: %s", e.Image)
						}
						var name string
						base := filepath.Base(e.File)
						ext := filepath.Ext(base)
						base = base[:len(base)-len(ext)]
						if len(r) == 1 {
							name = fmt.Sprintf("%s_%d.%s", base, e.Line, format)
						} else {
							name = fmt.Sprintf("%s_%d_%d.%s", base, e.Line, i, format)
						}

						dst, err := os.Create(name)
						if err != nil {
							log.Fatal(err)
						}
						_, err = io.Copy(dst, src)
						if err != nil {
							log.Fatal(err)
						}
						err = dst.Close()
						if err != nil {
							log.Fatal(err)
						}
						if *quote {
							_, err = fmt.Fprint(out, "> ")
							if err != nil {
								log.Fatal(err)
							}
						}
						if e.Title == "" {
							_, err = fmt.Fprintf(out, "![%s](%s)\n", e.Text, name)
							if err != nil {
								log.Fatal(err)
							}
						} else {
							_, err = fmt.Fprintf(out, "![%s](%s %q)\n", e.Text, name, e.Title)
							if err != nil {
								log.Fatal(err)
							}
						}
						if len(r) != 1 && i != len(r)-1 {
							_, err = fmt.Fprintln(out)
							if err != nil {
								log.Fatal(err)
							}
						}
					}
				}
			}
			_, err = fmt.Fprintln(out, ticks)
			if err != nil {
				log.Fatal(err)
			}
		}
		line++
		c, ok := mdText[line]
		if !ok {
			if wasComment {
				_, err = fmt.Fprintln(out, ticks)
				if err != nil {
					log.Fatal(err)
				}
			}
			wasComment = false
			_, err = fmt.Fprintln(out, sc.Text())
			if err != nil {
				log.Fatal(err)
			}
		} else {
			text := strings.TrimPrefix(c.Text, "/*{md}")
			text = strings.TrimSuffix(text, "*/")
			if !wasComment {
				_, err = fmt.Fprint(out, ticks)
				if err != nil {
					log.Fatal(err)
				}
			} else {
				text = strings.TrimPrefix(text, "\n")
			}
			indent := fset.Position(c.Pos()).Column - 1
			text = strings.Replace(text, "\n"+strings.Repeat("\t", indent), "\n", -1)
			_, err = fmt.Fprintf(out, "%s%s\n", text, ticks)
			if err != nil {
				log.Fatal(err)
			}
			n := fset.Position(c.End()).Line - line
			err = skip(n, sc)
			if err != nil {
				log.Fatal(err)
			}
			line += n
			wasComment = false
		}
	}
	if !wasComment {
		_, err = fmt.Fprintln(out, ticks)
		if err != nil {
			log.Fatal(err)
		}
	}
}

func longestTicks(s string) int {
	var m, l int
	for _, r := range s {
		if r != '`' {
			if l > m {
				m = l
			}
			l = 0
			continue
		}
		l++
	}
	return m
}

func skip(n int, sc *bufio.Scanner) error {
	for n--; sc.Scan() && n > 0; n-- {
	}
	if n > 0 {
		if sc.Err() != nil {
			return sc.Err()
		}
		return io.ErrUnexpectedEOF
	}
	return nil
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// run runs the source described by fset and f and collects output events.
func run(fset *token.FileSet, f *ast.File, args []string) (map[int][]enc.Event, error) {
	// Retain line numbering to be consistent with the
	// source as given.
	cfg := printer.Config{
		Mode:     printer.UseSpaces | printer.TabIndent | printer.SourcePos,
		Tabwidth: 8,
	}
	wd, err := os.Getwd()
	if err != nil {
		return nil, err
	}
	tmp, err := ioutil.TempFile(wd, "gd-*.go")
	if err != nil {
		return nil, err
	}
	defer os.Remove(tmp.Name())
	err = cfg.Fprint(tmp, fset, f)
	if err != nil {
		return nil, err
	}
	err = tmp.Close()
	if err != nil {
		return nil, err
	}

	args = append([]string{"run", tmp.Name()}, args...)
	gorun := exec.Command("go", args...)
	var buf bytes.Buffer
	gorun.Stdout = &buf
	gorun.Stderr = os.Stderr
	err = gorun.Run()
	if err != nil {
		return nil, err
	}
	dec := json.NewDecoder(&buf)

	events := make(map[int][]enc.Event)
	for {
		var e enc.Event
		err = dec.Decode(&e)
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, err
		}
		line := lastLineOf(e.Func, e.Line, fset, f)
		events[line] = append(events[line], e)
	}
	return events, nil
}

func formatCLargs(args []string) string {
	var buf strings.Builder
	for i, s := range args {
		if i != 0 {
			buf.Write([]byte{' '})
		}
		if strings.Contains(s, " ") {
			s = `"` + s + `"`
		}
		fmt.Fprint(&buf, s)
	}
	return buf.String()
}

// lastLineOf returns the last line of the outer-most function
// on the given line matching the selector expression in fn.
// It is not possible to differentiate between calls to the same
// function on the same line due to the absence of a column field
// in runtime.Func.
func lastLineOf(fn string, line int, fset *token.FileSet, f *ast.File) int {
	end, ok := cache[funcLine{name: fn, line: line}]
	if ok {
		return end
	}
	ast.Inspect(f, func(n ast.Node) bool {
		exp, ok := n.(*ast.CallExpr)
		if !ok {
			return true
		}
		ident, ok := exp.Fun.(*ast.SelectorExpr)
		if !ok {
			return true
		}
		pos := fset.Position(exp.Pos())
		if pos.Line != line || fmt.Sprintf("%s.%s", ident.X, ident.Sel.Name) != fn {
			return true
		}
		end = fset.Position(exp.End()).Line
		cache[funcLine{name: fn, line: line}] = end
		return false
	})
	return end
}

var cache = make(map[funcLine]int)

type funcLine struct {
	name string
	line int
}
